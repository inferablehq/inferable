import { useMemo, useCallback } from "react";
import { createApiClient } from "../createClient";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

/**
 * Authentication options for using cluster-based authentication with an API secret key
 */
export type AuthOptionsCluster = {
  /** Authentication type identifier */
  authType: "cluster";
  /**
   * API secret key for cluster authentication.
   * This can be obtained from your Inferable dashboard.
   */
  apiSecret: string;
};

/**
 * Authentication options for using custom token-based authentication
 */
export type AuthOptionsCustom = {
  /** Authentication type identifier */
  authType: "custom";
  /**
   * Custom authentication token.
   * This should be generated by your authentication system.
   */
  customAuthToken: string;
};

/** Combined type for all supported authentication options */
export type AuthOptions = AuthOptionsCluster | AuthOptionsCustom;

/**
 * Configuration options for creating an Inferable client instance
 */
export type UseInferableOptions = {
  /**
   * The unique identifier for your Inferable cluster.
   * This can be found in your Inferable dashboard.
   */
  clusterId: string;
  /**
   * Optional base URL for the Inferable API.
   * @default "https://api.inferable.ai"
   */
  baseUrl?: string;
  /**
   * Optional pre-configured API client instance.
   * Use this if you need custom client configuration.
   */
  apiClient?: ReturnType<typeof createApiClient>;
} & AuthOptions;

/**
 * React hook for creating and managing an Inferable API client instance.
 * This hook provides methods for creating and managing runs, along with the underlying API client.
 *
 * @param options - Configuration options for the Inferable client
 * @returns Object containing the client instance and utility methods
 *
 * @example
 * ```tsx
 * // Basic usage with custom authentication
 * const inferable = useInferable({
 *   clusterId: "my-cluster",
 *   authType: "custom",
 *   customAuthToken: "my-token"
 * });
 *
 * // Create a new run
 * const { id } = await inferable.createRun({
 *   initialPrompt: "Hello, how can you help me?",
 *   name: "My Test Run"
 * });
 *
 * @example
 * ```tsx
 * // Usage with result schema validation
 * const ResultSchema = z.object({
 *   summary: z.string(),
 *   confidence: z.number()
 * });
 *
 * const inferable = useInferable({
 *   clusterId: "my-cluster",
 *   authType: "cluster",
 *   apiSecret: "my-secret"
 * });
 *
 * const { id } = await inferable.createRun({
 *   initialPrompt: "Analyze this text...",
 *   resultSchema: ResultSchema,
 *   model: "claude-3-5-sonnet"
 * });
 *
 * @example
 * ```tsx
 * // List all runs
 * const { runs } = await inferable.listRuns();
 * console.log(runs.map(run => run.name));
 * ```
 */
export function useInferable(options: UseInferableOptions): {
  client: ReturnType<typeof createApiClient>;
  clusterId: string;
  createRun: (createRunOptions: {
    initialPrompt: string;
    systemPrompt?: string;
    name?: string;
    model?: "claude-3-5-sonnet" | "claude-3-haiku";
    resultSchema?: z.ZodObject<any>;
    metadata?: Record<string, string>;
    interactive?: boolean;
  }) => Promise<{ id: string }>;
  listRuns: () => Promise<{
    runs: Array<{
      id: string;
      name: string;
      userId: string | null;
      createdAt: Date;
      status: "pending" | "running" | "paused" | "done" | "failed" | null;
      test: boolean;
      configId: string | null;
      configVersion: number | null;
      feedbackScore: number | null;
    }>;
  }>;
} {
  const client = useMemo(
    () =>
      options.apiClient ??
      createApiClient({
        authHeader:
          options.authType === "custom"
            ? `custom ${options.customAuthToken}`
            : `bearer ${options.apiSecret}`,
        baseUrl: options.baseUrl,
      }),
    [options]
  );

  const createRun = useCallback(
    (createRunOptions: {
      initialPrompt: string;
      systemPrompt?: string;
      name?: string;
      model?: "claude-3-5-sonnet" | "claude-3-haiku";
      resultSchema?: z.ZodObject<any>;
      metadata?: Record<string, string>;
      interactive?: boolean;
    }) => {
      return client
        .createRun({
          params: {
            clusterId: options.clusterId,
          },
          body: {
            initialPrompt: createRunOptions.initialPrompt,
            systemPrompt: createRunOptions.systemPrompt,
            name: createRunOptions.name,
            model: createRunOptions.model,
            resultSchema: createRunOptions.resultSchema
              ? zodToJsonSchema(createRunOptions.resultSchema)
              : undefined,
            metadata: createRunOptions.metadata,
            interactive: createRunOptions.interactive,
          },
        })
        .then(response => {
          if (response.status !== 201) {
            throw new Error(
              `Could not create run. Status: ${response.status} Body: ${JSON.stringify(response.body)}`
            );
          }
          return response.body;
        });
    },
    [client, options.clusterId]
  );

  const listRuns = useCallback(() => {
    if (!options.clusterId) {
      throw new Error("Cluster ID is required");
    }

    return client
      .listRuns({
        params: {
          clusterId: options.clusterId,
        },
      })
      .then(response => {
        if (response.status !== 200) {
          throw new Error(
            `Could not list runs. Status: ${response.status} Body: ${JSON.stringify(response.body)}`
          );
        }
        const runs = Array.isArray(response.body) ? response.body : [];
        return {
          runs,
        };
      });
  }, [client, options.clusterId]);

  return {
    client: client,
    clusterId: options.clusterId,
    createRun,
    listRuns,
  };
}
